<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
 PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
 "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
 <!-- namespace跟接口绑定，就是接口的全类名 -->
 <mapper namespace="com.tongji.dao.EmployeeMapperPlus">
 
<!-- 自定义某个javaBean的封装规则，type:自定义规则的java类型 ;id：唯一的标识方便引用-->
    <resultMap type="com.tongji.bean.Employee" id="MyEmp">
         <!-- 指定主键列的封装规则 ,也可以在reslut中定义，但是单独定义有底层的优化规则-->
         <!-- column:指定那一列; property:指定对应的javaBean属性 -->
         <id column="employee_id" property="id"/>
         
         <!-- 定义普通列的封装规则 ,虽然可以自动封装，但是只要写就全部写上-->
         <result column="last_name" property="lastName"/>
         <result column="hire_date" property="hireDate"/>
    </resultMap>
 
 <!-- public Employee getEmpById(Integer id); -->
 <!-- 这里的resultType可以在全局配置里面取别名为employee,在类上加注解@Alias("emp") 最后只用emp，不然必须写全类名-->
 <!-- resultType和reslutMap只能二选一 -->
    <select id="getEmpById"  resultMap="MyEmp">
        select * from employees where employee_id=#{id}
    </select>
 
 <!-- 场景1：
         员工和部门是有主外键关联的。参询Employee的同时把员工对应的部门
   Employee === Department
   
  -->
 <!-- 联合查询：级联属性封装结果集 -->
		  <!-- 自定义某个javaBean的封装规则，type:自定义规则的java类型 ;id：唯一的标识方便引用-->
		    <resultMap type="com.tongji.bean.Employee" id="MyEmpJoin">
		         <!-- 指定主键列的封装规则 ,也可以在reslut中定义，但是单独定义有底层的优化规则-->
		         <!-- column:指定那一列; property:指定对应的javaBean属性 -->
		         <id column="employee_id" property="id"/>
		         
		         <!-- 定义普通列的封装规则 ,虽然可以自动封装，但是只要写就全部写上-->
		         <result column="last_name" property="lastName"/>
		         <result column="hire_date" property="hireDate"/>
		         <result column="department_id" property="dept.id"/>
		         <result column="department_name" property="dept.departmentName"/>
		    </resultMap>
		    
		    
<!-- 使用association指定联合的javaBean对象 -->
		    <!-- 自定义某个javaBean的封装规则，type:自定义规则的java类型 ;id：唯一的标识方便引用-->
		    <resultMap type="com.tongji.bean.Employee" id="MyEmpAsso">
		         <!-- 指定主键列的封装规则 ,也可以在reslut中定义，但是单独定义有底层的优化规则-->
		         <!-- column:指定那一列; property:指定对应的javaBean属性 -->
		         <id column="employee_id" property="id"/>
		         
		         <!-- 定义普通列的封装规则 ,虽然可以自动封装，但是只要写就全部写上-->
		         <result column="last_name" property="lastName"/>
		         <result column="hire_date" property="hireDate"/>
		         <!-- assocation 可以指定联合对象的javaBean对象
		         property="dept"指定哪个属性是联合对象
		         javaType:指定这个属性对象的类型【不能省，不然不知道怎么封装】 -->
		         <association property="dept" javaType="com.tongji.bean.Department">
		            <id column="department_id" property="id"/>
		            <result column="department_name" property="departmentName"/>
		         </association>
		    </resultMap>
		    
		 <!-- public Employee getEmpAndDept(Integer id); -->
			 <select id="getEmpAndDept"  resultMap="MyEmpAsso">
			      select  e.employee_id employee_id,e.last_name last_name,e.department_id department_id,
			      e.hire_date hire_date,d.department_name department_name
			      from employees e,departments d
			      where e.department_id=d.department_id
			      and e.employee_id =#{id}
			 </select>
 
 
<!-- 使用association进行分步查询 
		    1.按照员工Id查询员工信息
		    2.根据查询员工信息中的department_id值去部门表中查出部门信息
		    3.部门设置到员工中：    
		    
		        分步查询的好处可以使用延迟加载（懒加载）；(按需加载)
		        Employee==>Dept：
		            我们每次查询Employee对象的时候，都将一起查询出来。
		            部门信息在我们使用的时候再去查询；
		            分段查询的基础之上加上两个配置：
		            在全局配置文件中加入
		        <setting name="lazyLoadingEnabled" value="true"/>
		        <setting name="aggressiveLazyLoading" value="false"/>
		      
		-->
		         <resultMap type="com.tongji.bean.Employee" id="MyEmpStep">
		                 <!-- 指定主键列的封装规则 ,也可以在reslut中定义，但是单独定义有底层的优化规则-->
		                 <!-- column:指定那一列; property:指定对应的javaBean属性 -->
		                 <id column="employee_id" property="id"/>
		
		                 <result column="last_name" property="lastName"/>
		                 <result column="hire_date" property="hireDate"/>
		                 <!-- association定义关联对象的封装规则
		                select:表明当前属性是调用select指定的方法查出的结果,namespace+id
		                column:指定将哪一列的值传给这个方法
		            
		                                                 流程：使用select指定的方法（传入column指定的这列参数的值）查出对象，并封装给property指定的属性
		                -->
		                 <association property="dept" 
		                    select="com.tongji.dao.DepartmentMapper.getDeptById"
		                    column="department_id">
		     
		                 </association>
		            </resultMap>
		        <select id="getEmpByIdStep" resultMap="MyEmpStep">
		            select * from employees where employee_id=#{id}
		        </select>
		        
<!-- 场景二：每个部门有很多员工，这个根据部门编号查询其员工 -->		        
<!-- //按照部门编号，查出该部门的所有员工
public List<Employee> getEmpsByDeptId(Integer deptId);	 -->        


 
    <select id="getEmpsByDeptId"  resultType="com.tongji.bean.Employee">
       select employee_id,last_name,hire_date from employees where department_id=#{deptId}
    </select>
 </mapper>
 
 
 
 