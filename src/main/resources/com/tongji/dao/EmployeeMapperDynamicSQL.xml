<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
 PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
 "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
 <!-- namespace是与对应的接口的全类名 -->
 <mapper namespace="com.tongji.dao.EmployeeMapperDynamicSQL"> 
<!--  //参询员工，传进来的员工携带哪个字段就用携带上那个字段。
public List<Employee> getEmpsByConditionIf(Employee employee);
-->
<cache eviction="FIFO" flushInterval="60000" readOnly="false" size="1024"></cache>
    <!--  
    eviction:缓存的回收策略：
        • LRU – 最近最少使用的：移除最长时间不被使用的对象。
        • FIFO – 先进先出：按对象进入缓存的顺序来移除它们。
        • SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。
        • WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。
        • 默认的是 LRU。
    flushInterval：缓存刷新间隔
        缓存多长时间清空一次，默认不清空，设置一个毫秒值
    readOnly:是否只读：
        true：只读；mybatis认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。
                 mybatis为了加快获取速度，直接就会将数据在缓存中的引用交给用户。不安全，速度快
        false：非只读：mybatis觉得获取的数据可能会被修改。
                mybatis会利用序列化&反序列的技术克隆一份新的数据给你。安全，速度慢
    size：缓存存放多少元素；
    type=""：指定自定义缓存的全类名；
            实现Cache接口即可；
    -->
    <select id="getEmpsByConditionIf" resultType="com.tongji.bean.Employee">
        select * from employees 
        <where>
            <if test="id!=null"> employee_id=#{id}</if>
            <!-- test：判断表达式（OGNL）
	            OGNL参照PPT或者官方文档。
	                 c:if  test
	                                     从参数中取值进行判断
	            
	                                      遇见特殊符号应该去写转义字符：w3c html上面查询出来lastName!="" 
	            &&：&amp;&amp;-->
             <if test="lastName!=null &amp;&amp; lastName!=&quot;&quot;"> 
                and last_name like #{lastName}
            </if>
            <if test="email!=null and email.trim()!=&quot;&quot;">
                and email=#{email}
            </if>
            <!-- ognl会进行字符串与数字的转换判断  "0"==0 -->
            <if test="gender==0 or gender==1">and gender=#{gender}</if>
        </where>      
    </select>
  
<!-- //参询员工，传进来的员工携带哪几个字段就用携带上哪几个字段,只不过我们拿trim标签来模拟
public List<Employee> getEmpsByConditionTrim(Employee employee); -->  
    
    <select id="getEmpsByConditionTrim" resultType="com.tongji.bean.Employee">
         select * from employees 
         <!-- 后面多出的and或者or where标签不能解决 
		        prefix="":前缀：trim标签体中是整个字符串拼串 后的结果。
		                prefix给拼串后的整个字符串加一个前缀 
		        prefixOverrides="":
		                前缀覆盖： 去掉整个字符串前面多余的字符
		        suffix="":后缀
		                suffix给拼串后的整个字符串加一个后缀 
		        suffixOverrides=""
		                后缀覆盖：去掉整个字符串后面多余的字符		                
		        -->
        <!-- 自定义字符串的截取规则 -->
        <trim prefix="where" suffixOverrides="and">
            <if test="id!=null"> employee_id=#{id} and</if>
             <if test="lastName!=null &amp;&amp; lastName!=&quot;&quot;"> 
                 last_name like #{lastName} and
            </if>
            <if test="email!=null and email.trim()!=&quot;&quot;">
                 email=#{email} and
            </if>
            <if test="gender==0 or gender==1"> gender=#{gender}</if>
        </trim>      
    </select>


<!-- //查询员工，是按照选择某个条件，而不是向上面一样，所有条件去全部封装起来。
    public List<Employee> getEmpsByConditionChoose(Employee employee);   -->
<select id="getEmpsByConditionChoose" resultType="com.tongji.bean.Employee">
    select * from employees 
    <where>
        <choose>
            <when test="id!=null">employee_id=#{id}</when>
            <when test="lastName!=null">last_name like #{lastName}</when>
            <when test="email!=null">email=#{email}</when>
            <otherwise> gender=0</otherwise>
            <!-- 否则就是把所有女生都查出来 -->
        </choose>
    </where>
</select> 
 
 
<!-- //传入一个员工，更新这个数据记录，以前是传指定几个更新指定几个，和以前不同，我们现在是对象你自带哪些值，我就更新哪些值
    <update id="updateEmp">
        update employees 
            set employee_id=#{id},last_name=#{lastName}
            where employee_id = #{id}
    </update>
    public void updateEmp(Employee employee); -->
<update id="updateEmp" >
    <!-- Set标签的使用，这样可以给我们自动去掉末尾的逗号 -->
        update employees 
        <set>
            <if test="lastName!=null">
                last_name=#{lastName},
            </if>
            <if test="email!=null">
                email=#{email},
            </if>
            <if test="gender!=null">
                gender=#{gender}
            </if>
        </set>
        where employee_id=#{id} 
        <!-- 多重条件推荐写在where标签里面 ，简便的这样也是可以的。-->
<!--        
        Trim：更新拼串
        update employees
        <trim prefix="set" suffixOverrides=",">
            <if test="lastName!=null">
                last_name=#{lastName},
            </if>
            <if test="email!=null">
                email=#{email},
            </if>
            <if test="gender!=null">
                gender=#{gender}
            </if>
        </trim>
        where id=#{id}  -->
</update> 
 
 
 <!-- //根据传入的集合，把集合里面的员工全部查出来
    类似以：select * from employees where id in(?,?,?,?)
    public  List<Employee> getEmpsByConditionForeach(List ids);
  -->
 <select id="getEmpsByConditionForeach" resultType="com.tongji.bean.Employee">
        select * from employees
        <!--
            collection：指定要遍历的集合：
                list类型的参数会特殊处理封装在map中，map的key就叫list
            item：将当前遍历出的元素赋值给指定的变量
            #{变量名}就能取出变量的值也就是当前遍历出的元素
            
            separator:每个元素之间的分隔符
            open：遍历出所有结果拼接一个开始的字符
            close:遍历出所有结果拼接一个结束的字符
            index:索引。遍历list的时候是index就是索引，item就是当前值
                                    遍历map的时候index表示的就是map的key，item就是map的值
          -->
        <foreach collection="ids" item="item_id" separator=","
            open="where employee_id in(" close=")" >
            #{item_id}
        </foreach>
</select>
 
 <!-- 批量保存 -->
 
 <!-- //批量插入很多条员工数据
    public void addEmps(@Param("emps") List<Employee> emps); 
    对于mysql
 MySQL下批量保存：可以foreach遍历   mysql支持values(),(),()语法
 -->
		 <insert id="addEmps" databaseId="mysql">
		    insert into customer (
		    <include refid="insertColumn"></include>
		    )
		    values
		    <foreach collection="emps" item="emp" separator=",">
		       (#{emp.id},#{emp.lastName},#{emp.email})
		    </foreach>
		 </insert> 
 
  <!-- 这种方式需要数据库连接属性dbconf中dbconf文件中mysql配置中,不能有空格
    意思就是可以发多条SQL语句，中间用分号隔开 ：  sql1;sql2；sql3;
    mysql.url=jdbc:mysql://127.0.0.1:3306/mydata?allowMultiQueries=true
        这种分号分隔多个sql可以用于其他的批量操作（删除，修改） -->
	     <!--  <insert id="addEmps" databaseId="mysql">
	        <foreach collection="emps" item="emp" separator=";">
	            insert into customer (id,name,email)
	            values(#{emp.id},#{emp.lastName},#{emp.email})
	        </foreach>
	     </insert>  -->
	 
	     
  <!-- Oracle数据库批量保存： 
  
  
        Oracle不支持values(),(),()
        Oracle支持的批量方式
        1、多个insert放在begin - end里面
            begin
                insert into employees(employee_id,last_name,email) 
                values(employees_seq.nextval,'test_001','test_001@atguigu.com');
                insert into employees(employee_id,last_name,email) 
                values(employees_seq.nextval,'test_002','test_002@atguigu.com');
            end;
        2、利用中间表：
            insert into employees(employee_id,last_name,email)
               select employees_seq.nextval,lastName,email from(
                      select 'test_a_01' lastName,'test_a_e01' email from dual
                      union
                      select 'test_a_02' lastName,'test_a_e02' email from dual
                      union
                      select 'test_a_03' lastName,'test_a_e03' email from dual
               )    
     -->
     <insert id="addEmps" databaseId="oracle" >
        <!-- oracle第一种批量方式 -->
        <!-- <foreach collection="emps" item="emp" open="begin" close="end;">
            insert into employees(employee_id,last_name,email) 
                values(employees_seq.nextval,#{emp.lastName},#{emp.email});
        </foreach> -->
        
        <!-- oracle第二种批量方式  -->
        insert into employees(
            <include refid="insertColumn"></include>
        )
       
                <foreach collection="emps" item="emp" separator="union"
                    open="select employees_seq.nextval,lastName,email from("
                    close=")">
                    select #{emp.lastName} lastName,#{emp.email} email from dual
                </foreach>
     </insert>
 
 <!-- 两个内置参数：
        不只是方法传递过来的参数可以被用来判断，取值。。。
        mybatis默认还有两个内置参数：
        _parameter:代表整个参数
            单个参数：_parameter就是这个参数
            多个参数：参数会被封装为一个map；_parameter就是代表这个map
        
        _databaseId:如果全局配置了databaseIdProvider标签。
            _databaseId就是代表当前数据库的别名oracle
      -->
<!-- 使用内置参数进行查询，不用区分不同的数据库了
    public List<Employee> getEmpsByInnerParamter(Employee employee);  -->
     <select id="getEmpsByInnerParamter" resultType="com.tongji.bean.Employee">
            <!-- bind：可以将OGNL表达式的值绑定到一个变量中，方便后来引用这个变量的值 
                                     这里主要是模糊查询的用户，前端直接输入a后面自动拼成%a% ，虽然是可以的但是不建议用，不灵活-->
            <bind name="_lastName" value="'%'+lastName+'%'"/>
            <if test="_databaseId=='mysql'">
                select 
                <include refid="insertColumn"></include>
                from customer
                <if test="_parameter!=null">
                    where name like #{lastName}
                </if>
            </if>
            <if test="_databaseId=='oracle'">
                select 
                <include refid="insertColumn"></include>
                from employees
                <if test="_parameter!=null">
                    where last_name like #{_parameter.lastName}
                    <!-- _parameter是可写可不写的 -->
                </if>
            </if>
     </select>
  
<!-- 
        抽取可重用的sql片段。方便后面引用 
        1、sql抽取：经常将要查询的列名，或者插入用的列名抽取出来方便引用
        2、include来引用已经抽取的sql：
        3、include还可以自定义一些property，sql标签内部就能使用自定义的属性
                <inclued refid="insertColumn">
                    <property name="testColomn" value="abc">
                include-property：取值的正确方式${prop},
                #{不能使用这种方式}
      -->
	  <sql id="insertColumn">
	    <if test="_databaseId=='oracle'">
	        employee_id,last_name,email
	    </if>
	    <if test="_databaseId=='mysql'">
	        id,name,email
	    </if>
	  </sql>
  
 </mapper>